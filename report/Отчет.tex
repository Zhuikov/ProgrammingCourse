\documentclass[12pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[OT1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{indentfirst} 			% Красная строка
\usepackage{cmap}					% поиск в PDF
\usepackage{mathtext} 				% русские буквы в формулах
%\usepackage{tikz-uml}               % uml диаграммы

% TODOs
\usepackage[%
  colorinlistoftodos,
  shadow
]{todonotes}

% Генератор текста
\usepackage{blindtext}

%------------------------------------------------------------------------------

% Подсветка синтаксиса
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
 
 % Цвета для кода
\definecolor{string}{HTML}{B40000} % цвет строк в коде
\definecolor{comment}{HTML}{008000} % цвет комментариев в коде
\definecolor{keyword}{HTML}{1A00FF} % цвет ключевых слов в коде
\definecolor{morecomment}{HTML}{8000FF} % цвет include и других элементов в коде
\definecolor{captiontext}{HTML}{FFFFFF} % цвет текста заголовка в коде
\definecolor{captionbk}{HTML}{999999} % цвет фона заголовка в коде
\definecolor{bk}{HTML}{FFFFFF} % цвет фона в коде
\definecolor{frame}{HTML}{999999} % цвет рамки в коде
\definecolor{brackets}{HTML}{B40000} % цвет скобок в коде
 
 % Настройки отображения кода
\lstset{
language=C, % Язык кода по умолчанию
morekeywords={*,...}, % если хотите добавить ключевые слова, то добавляйте
 % Цвета
keywordstyle=\color{keyword}\ttfamily\bfseries,
stringstyle=\color{string}\ttfamily,
commentstyle=\color{comment}\ttfamily\itshape,
morecomment=[l][\color{morecomment}]{\#}, 
 % Настройки отображения     
breaklines=true, % Перенос длинных строк
basicstyle=\ttfamily\footnotesize, % Шрифт для отображения кода
backgroundcolor=\color{bk}, % Цвет фона кода
%frame=lrb,xleftmargin=\fboxsep,xrightmargin=-\fboxsep, % Рамка, подогнанная к заголовку
frame=tblr
rulecolor=\color{frame}, % Цвет рамки
tabsize=3, % Размер табуляции в пробелах
showstringspaces=false,
 % Настройка отображения номеров строк. Если не нужно, то удалите весь блок
numbers=left, % Слева отображаются номера строк
stepnumber=1, % Каждую строку нумеровать
numbersep=5pt, % Отступ от кода 
numberstyle=\small\color{black}, % Стиль написания номеров строк
 % Для отображения русского языка
extendedchars=true,
literate={Ö}{{\"O}}1
  {Ä}{{\"A}}1
  {Ü}{{\"U}}1
  {ß}{{\ss}}1
  {ü}{{\"u}}1
  {ä}{{\"a}}1
  {ö}{{\"o}}1
  {~}{{\textasciitilde}}1
  {а}{{\selectfont\char224}}1
  {б}{{\selectfont\char225}}1
  {в}{{\selectfont\char226}}1
  {г}{{\selectfont\char227}}1
  {д}{{\selectfont\char228}}1
  {е}{{\selectfont\char229}}1
  {ё}{{\"e}}1
  {ж}{{\selectfont\char230}}1
  {з}{{\selectfont\char231}}1
  {и}{{\selectfont\char232}}1
  {й}{{\selectfont\char233}}1
  {к}{{\selectfont\char234}}1
  {л}{{\selectfont\char235}}1
  {м}{{\selectfont\char236}}1
  {н}{{\selectfont\char237}}1
  {о}{{\selectfont\char238}}1
  {п}{{\selectfont\char239}}1
  {р}{{\selectfont\char240}}1
  {с}{{\selectfont\char241}}1
  {т}{{\selectfont\char242}}1
  {у}{{\selectfont\char243}}1
  {ф}{{\selectfont\char244}}1
  {х}{{\selectfont\char245}}1
  {ц}{{\selectfont\char246}}1
  {ч}{{\selectfont\char247}}1
  {ш}{{\selectfont\char248}}1
  {щ}{{\selectfont\char249}}1
  {ъ}{{\selectfont\char250}}1
  {ы}{{\selectfont\char251}}1
  {ь}{{\selectfont\char252}}1
  {э}{{\selectfont\char253}}1
  {ю}{{\selectfont\char254}}1
  {я}{{\selectfont\char255}}1
  {А}{{\selectfont\char192}}1
  {Б}{{\selectfont\char193}}1
  {В}{{\selectfont\char194}}1
  {Г}{{\selectfont\char195}}1
  {Д}{{\selectfont\char196}}1
  {Е}{{\selectfont\char197}}1
  {Ё}{{\"E}}1
  {Ж}{{\selectfont\char198}}1
  {З}{{\selectfont\char199}}1
  {И}{{\selectfont\char200}}1
  {Й}{{\selectfont\char201}}1
  {К}{{\selectfont\char202}}1
  {Л}{{\selectfont\char203}}1
  {М}{{\selectfont\char204}}1
  {Н}{{\selectfont\char205}}1
  {О}{{\selectfont\char206}}1
  {П}{{\selectfont\char207}}1
  {Р}{{\selectfont\char208}}1
  {С}{{\selectfont\char209}}1
  {Т}{{\selectfont\char210}}1
  {У}{{\selectfont\char211}}1
  {Ф}{{\selectfont\char212}}1
  {Х}{{\selectfont\char213}}1
  {Ц}{{\selectfont\char214}}1
  {Ч}{{\selectfont\char215}}1
  {Ш}{{\selectfont\char216}}1
  {Щ}{{\selectfont\char217}}1
  {Ъ}{{\selectfont\char218}}1
  {Ы}{{\selectfont\char219}}1
  {Ь}{{\selectfont\char220}}1
  {Э}{{\selectfont\char221}}1
  {Ю}{{\selectfont\char222}}1
  {Я}{{\selectfont\char223}}1
  {і}{{\selectfont\char105}}1
  {ї}{{\selectfont\char168}}1
  {є}{{\selectfont\char185}}1
  {ґ}{{\selectfont\char160}}1
  {І}{{\selectfont\char73}}1
  {Ї}{{\selectfont\char136}}1
  {Є}{{\selectfont\char153}}1
  {Ґ}{{\selectfont\char128}}1
  {\{}{{{\color{brackets}\{}}}1 % Цвет скобок {
  {\}}{{{\color{brackets}\}}}}1 % Цвет скобок }
}
 
 % Для настройки заголовка кода
\usepackage{caption}
\DeclareCaptionFont{white}{\color{сaptiontext}}
\DeclareCaptionFormat{listing}{\parbox{\linewidth}{\colorbox{сaptionbk}{\parbox{\linewidth}{#1#2#3}}\vskip-4pt}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\renewcommand{\lstlistingname}{Код} % Переименование Listings в нужное именование структуры


%------------------------------------------------------------------------------

\author{Жуйков Артем}
\title{Программирование}
\begin{document}
\listoftodos
\maketitle
\chapter{Основные конструкции языка}
%############################################################
\section{Задание 1}
\subsection{Задание}
Найти длину отрезка, соединяющего точки на плоскости с координатами $(x_1, y_1)$ и $(x_1 , y_1)$.

\subsection{Теоретические сведения}

%Конструкции языка, библиотечные функции, инструменты использованные при разработке приложения.
%Сведения о предметной области, которые позволили реализовать алгоритм решения задачи.

Для вычисления длины отрезка по заданным координатам концов воспользуемся формулой:
\begin{equation}
l = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}
\end{equation}
и используем заголовочный файл math.h.

\subsection{Проектирование}
%Какие функции было решено выделить, какие у этих функций контракты, как организовано взаимодействие с пользователем (чтение/запись из консоли, из файла, из параметров командной строки), форматы файлов и др.
Введем функцию void \verb+length_of_segment_ui()+, которая будет отвечать за взаимодействие с пользователем. Из консоли сначала считаем координаты $ (x_1, y_1) $ первой точки и запишем их в соответствующие переменные \verb+х_1+ и \verb+у_1+.
Координаты второй точки запишем в переменные \verb+x_2+, \verb+y_2+ соответственно.
Выделим функцию, которая получает четыре параметра - координаты точек и возвращает расстояние между ними: \verb+float length_of_segment(int a, int b, int c, int, d)+. Будем выводить его в консоль с точностью до двух знаков после запятой.
\subsection{Описание тестового стенда и методики тестирования}
%Среда, компилятор, операционная система, др.
Среда разработки: Qt Creator 3.5.0 (opensource) \\
Компилятор: gcc (Debian 4.9.2-10) 4.9.2 \\
Операционная система: Debian GNU/Linux 8.1 \\
%Ручное тестирование, автоматическое, статический анализ кода, динамический.
Для проверки работы программы использовалось ручное тестирование, а так же автоматическое. Результаты автоматического тестирования ......
\subsection{Тестовый план и результаты тестирования}
%Описание по шагам хода тестирования, с указанием соответствия или несоответствия ожидаемым результатам.
Описание хода ручного тестирования:
\begin{enumerate}
\item
Пусть координаты первой точки равны (0, 0), а координаты второй точки - (3, 4). Тогда длина отрезка, соединяющего эти точки будет равна: 
\begin{equation}
l = \sqrt{(3 - 0) ^ 2 + (4 - 0) ^ 2} = \sqrt{3 ^ 2 + 4 ^ 2} = \sqrt{25} = 5
\end{equation}
Для таких исходных данных программа вывела 5.00, что соответствует ожидаемому результату.
\item 
Пусть координаты первой точки -- (-1, -2), а координаты второй точки -- (30, 52). Вычислим расстояние между точками в этом случае:
\begin{equation}
l = \sqrt{(30 - (-1))^2 + (52 - (-2))^2} = \sqrt{31^2 + 54^2} = \sqrt{3877} \approx 62,26656...
\end{equation}
Программа вывела число 60.27, что с учетом введенного округления соответствует ожидаемому результату.
\item
Пусть координаты первой точки (16, 16), координаты второй точки (-4, -10). Тогда расстояние между точками равно:
\begin{equation}
l = sqrt{(16 - (-4))^2 + (16 - (-10))^2} = \sqrt{1076} \approx 32,80244...
\end{equation}
Программа вывела число 32,80, что с учетом округления соответствует ожидаемому результату. 
\end{enumerate} 

Код проверялся программой cppcheck.c версии 1.67. Утилита вывела следующие ошибки: \\
(portability) scanf without field width limits can crash with huge input data on some versions of libc.\\
Это значит, что в форматной строке нужно указать границу вводимой переменной. Если пользователь введет число, большее максимально допустимого, например, в типе int, это приведет к ошибке. Чтобы такого не произошло, форматная строка должна иметь следующий вид: "\%100d".
\subsection{Выводы}
%Слова от чистого сердца
В ходе работы над задачей автор получил новые знания о языке С: структуры, консольный ввод-вывод. Научился пользоваться функциональностью дебага в среде QtCreator. Написанная программа была протестирована. Результаты всех тестов соответствуют ожидаемым результатам, следовательно, можно сделать вывод, что программа работает верно. 

\section{Задание 2}
\subsection{Задание}
Найти корни биквадратного уравнения: 
\begin{equation}
\label{biquadratic}
y = ax^{4} + bx^{2} + c
\end{equation}
\subsection{Теоретические сведения}
Обозначим исходное уравнение \ref{biquadratic}.

Чтобы найти корни биквадратного уравнения, можно решить его, как квадратное, относительно $x^{2}$, т.е
\begin{equation}
\label{quadratic}
  a(x^{2})^{2} + bx^{2} + c = 0
\end{equation}

При этом корнем уравнения \ref{quadratic} будем называть $x^{2}$.
Уравнение \ref{biquadratic} будет иметь корни, если хотя бы один корень уравнения \ref{quadratic} неотрицателен. \\
Рассмотрим уравнение \ref{quadratic}. Уравнение имеет корни (или не имеет их) в зависимости от дискриминанта. \\
Если дискриминант меньше нуля, то уравнение \ref{quadratic}, а следовательно и уравнение \ref{biquadratic}, не будет иметь решений. В этом случае сразу известен ответ задачи: исходное уравнение не имеет решений. \\
Если дискриминант равен нулю, то корни уравнения (2) не зависят от него. (x$^{2} = \dfrac{-b \pm \sqrt{D}}{2a}$, где D = 0). При этом биквадратное уравнение будет иметь два корня, если x$^{2}$ > 0; один корень (равный нулю), если x$^{2}$ = 0 или не иметь корней, если x$^{2}$ < 0. \\ 
Если дискриминант больше нуля, то уравнение (2) имеет два корня. Возможны случаи: \\
если оба корня отрицательны, то уравнение (1) не имеет решений; \\
если один корень отрицательный, а другой равен нулю, то исходное уравнение имеет единственный корень, равный нулю; \\
если один корень равен нулю, а второй положительный, то уравнение (1) имеет три корня, один из которых - нуль; \\
если оба корня положительны, то уравнение (1) имеет четыре корня. 
\subsection{Проектирование}
Обозначим a, b, c - коэффициенты биквадратного уравнения. \\
Создадим структуру \verb+Solutions_of_equation+, в которую в последующем запишем корни (максимум 4). Помимо значения корней будем хранить в ней и их существование. Для этого у каждого корня будет соответствующее поле равное еденице, если корень существует и нулю в противном случае. Если корня не существует, то он не выведется в ответе. Также корень не будет напечатан, если он равен корню, выведенному ранее. \\
\begin{enumerate}
\item
Функция void \verb+ solution_of_equation_ui()+ отвечает за взаимодействие с пользователем. Она считывает коэффициенты уравнения из консоли и вызывает функцию \verb+int solve_the_equation+(int a, int b, int c, struct \verb+Solutions_of_equations* f)+.  \\
Введем функцию, вычисляющую дискриминант уравнения: int \verb+sign_discriminant+(int a, int b, int c). Функция вернет нуль, если дискриминант отрицательный и единицу, если дискриминант больше либо равен нулю. \\
\item
Функция  \verb+int solve_the_equation+(int a, int b, int c, struct \verb+Solutions_of_equations* f)+ (при a $\neq$ 0) будет анализировать значение, которое вернула предыдущая функция, и, в  зависимости от него, вызывать соответствующую функцию. Если дискриминант меньше нуля функция возвращает нуль. В противном случае, функция вызовет функцию void \verb+ calculating_of_solutions+(int, int, int, struct \verb+Solutions_of_equation*)+ и вернет единицу. 
\item
Функция void \verb+calculating_of_solutions+(int, int, int, struct \verb+Solutions_of_equation*)+ вычисляет корни уравения, записывает их в структуру, а также обозначает их существование путем присваивания единицы в соответствующее поле структуры. В конце работы функция вызывает функцию void \verb+analysis_of_solutions+(struct \verb+Solutions_of_equation *)+. \\
\item
Функция void \verb+ analysis_of_solutions(struct Solutions_of_equation *)+ анализирует полученные в структуре корни: если какие-то два корня равны и при этом существуют оба, то функция присвоит нуль в поле структуры, отвечающее за существование корня. Таким образом корень не будет выводиться дважды. \\
\end{enumerate}
После работы всех функций, мы вернемся в функцию \verb+solution_of_equation_ui+. Она выведет решения уравнения, если функция \verb+solve_the_equation+ вернула 1 или выведет на экран "Не имеет решений$"$, если последняя функция вернула 0. \\
Для корней уравнения используем тип float и будем выводить их с точностью до двух знаков после запятой. 
\subsection{Описание тестового стенда и методики тестирования}
Среда разработки: Qt Creator 3.5.0 (opensource)\\
Компилятор: gcc (Debian 4.9.2-10) 4.9.2
Операционная система: Debian GNU/Linux 8.1 \\
%Ручное тестирование, автоматическое, статический анализ кода, динамический.
При решении задачи использовалось автоматическое тестирование.\\
Программа проверялась утилитой cppcheck: (portability) scanf without field width limits can crash with huge input data on some versions of libc.\\
Ошибка аналогична ошибке в предыдущей задаче, нужно указать максимально допустимое значение переменной в форматной строке scanf. 
\subsection{Тестовый план и результаты тестирования}
\begin{center}
Результаты автоматического тестирования тестирования:
\end{center}
\begin{tabular}{|c|c|c|} 
\hline
Входные данные & Результат работы программы & Ожидаемый результат \\
\hline
1 -3 2 & 1.41; -1,41; 1.00; -1.00 & 1.41; -1.41; 1; -1 \\
\hline
2 -8 0 & 2.00; -2.00; 0 & 0; 2; -2 \\
\hline 
1 0 0 & 0 & 0 \\
\hline
\end{tabular} 
\\
\begin{center}
Таким образом, программа успешно прошла все представленные тесты. 
\end{center}

\subsection{Выводы}
Решая эту задачу, автор научился разделять одну сложную программу на несколько функций. Одни из них отвечают за математику, другие - за взаимодействие с пользователем. 
%############################################################
\chapter{Циклы}
\section{Задание 1}
\subsection{Задание}
Вывести на экран таблицу пересчета миль в километры и обратно до заданного расстояния в километрах, по возрастанию расстояний, как указано в примере (1 миля = 1.609 км). Пример для 5 километров: \\
мили  км \\
0.62 1.00 \\
1.00 1.61 \\
1.24 2.00 \\
1.86 3.00 \\
2.00 3.22 \\
2.49 4.00 \\
3.00 4.83 \\
3.11 5.00 \\
\subsection{Теоретические сведения}
%Конструкции языка, библиотечные функции, инструменты использованные при разработке приложения.
%Сведения о предметной области, которые позволили реализовать алгоритм решения задачи.

Для решения задачи воспользуемся циклом с предусловием. Будем выводить значения миль и километров, если хотя бы одно из них целое число. Повторяем это до тех пор, пока километры не станут больше необходимого числа. 
\subsection{Проектирование}
%Какие функции было решено выделить, какие у этих функций контракты, как организовано взаимодействие с пользователем (чтение/запись из консоли, из файла, из параметров командной строки), форматы файлов и др.
За взаимодействие с пользователем будет отвечать функция void \verb+ km_to_miles_ui()+. Она же будет проверять, является ли натуральным введенное число километров. В случае, если введенное число не удовлетворяет данному условию, программа прекращает работу и выводит сообщение об ошибке. Если введенное число километров является натуральным числом, запускается функция void \verb+ km_to_miles(int km)+, которая считает и выводит необходимую таблицу до заданного числа километров. Передадим функции это число, как параметр. \\
Рассмотрим функцию void \verb+ km_to_miles(int)+. Начальные значения миль и километров равны 0.62 и 1.00 соответственно. \\
В цикле будем выполнять следующие действия: \\
Выведем строчку со значениями миль и километров, при этом число километров всегда будет целое. (Обозначим эту строку "*"). Пока число километров не станет больше нужного числа, будем увеличивать его на единицу. Затем пересчитаем соответствующее число миль по формуле: мили = $\frac{km}{1.609}$, где km - число километров. \\
Чтобы в таблице были не только целые значения километров, но и целые значения миль, в начале каждой итерации цикла будем проверять, не стало ли текущее значение миль больше целого. Для этого будем сравнивать его с переменной, содержащей следующее целое число миль, которое необходимо вывести с соответствующим значением числа километров. (Пусть это переменная m). Изначально ее значение равно единице, т.к это следующее целое число миль для 0.62. \\
Если число миль "перескочило" через m, то перед тем, как вывести строку (*), выведем строку для целого числа миль, которое находится в m. Тогда число километров для этой строки будет равно: километры = 1.609 * мили = 1.609 * m. Тут же увеличим m на единицу. \\
После проверки условия, выведем строку "*", увеличим километры на единицу, пересчитаем число миль для нового значения километров и перейдем к следующей итерации цикла.  \\
Будем выводить таблицу в консоль. Числа - с точностью до двух знаков после запятой. Так мы выведем таблицу по образцу, представленном в условии задания. 
\subsection{Описание тестового стенда и методики тестирования}
Среда разработки: Qt Creator 3.5.0 (opensource)\\
Компилятор: gcc (Debian 4.9.2-10) 4.9.2 \\
Операционная система: Debian GNU/Linux 8.1 \\
При решении задачи использовалось ручное тестирование. 
\subsection{Тестовый план и результаты тестирования}
Передадим программе число 11. Программа выводит: \\
Мили Километры\\
0.62 1.00 \\
1.00 1.61 \\
1.24 2.00 \\
1.86 3.00 \\
2.00 3.22 \\
2.49 4.00 \\
3.00 4.83 \\
3.11 5.00 \\
3.73 6.00 \\
4.00 6.44 \\
4.35 7.00 \\
4.97 8.00 \\
5.00 8.04 \\
5.59 9.00 \\
6.00 9.65 \\
6.22 10.00 \\
6.84 11.00 \\
Визуально таблица соответствует примеру из условия. Заметим, что до пяти километров программа дает верный ответ. Посчитаем, например, значение миль для 8.00 километров. Мили = $\frac{8.00}{1.609}$ = 4.9720... С учетом округления, то же число напечатано в таблице. Для 11.00 километров число миль равно: $\frac{11.00}{1.609}$ = 6,83654..., что соответствует табличному. \\
Программа проверялась утилитой cppcheck. Была найдена единственная ошбика, аналогичная ошибкам в предыдущих заданиях.
\subsection{Выводы}
При написании программы удалось избежать перебора значений километров с шагом 0.001, вычисления соответствующего значения миль и вывода строки, если одно из них целое. Программа корректно выводит на экран таблицу пересчета миль в километры и обратно до заданного расстояния в километрах, по возрастанию расстояний.

\chapter{Матрицы}
\section{Задание 1}
\subsection{Задание}
Каждый элемент a$_{i j}$ матрицы A(m, n) заменить суммой элементов подматрицы A'(i, j), расположенной в левом верхнем углу матрицы A.
\subsection{Теоретические сведения}
%Конструкции языка, библиотечные функции, инструменты использованные при разработке приложения.
%Сведения о предметной области, которые позволили реализовать алгоритм решения задачи.
Размер исходной матрицы равен m $\times$ n. Обозначим исходную матрицу A, а матрицу, которую нужно  получить B.\\
Для обработки двумерного массива воспользуемся динамическим выделением памяти. Функция malloc(N) из библиотеки stdlib.h выделяет ячейки памяти для N байт и возвращает адрес на первую из них. Для начала создадим массив длинной n. Будем хранить в нем n указателей, каждый из которых содержит адрес первой ячейки n-ого массива из m элементов. Таким образом, получим n массивов длинной m, где n-ый массив - n-ый столбец в матрице. \\
Для нахождения элемента B$_{i j}$, будем динамично его вычислять. Он равен ans + C, где ans - ответ для предыдущего элемента B$_{i j-1}$, а C - сумма элементов столбца j до элемента B$_{i j}$, включая его самого. Для нулевой строки C = 0, а для нулевого столбца ans = 0.
\subsection{Проектирование}
%Какие функции было решено выделить, какие у этих функций контракты, как организовано взаимодействие с пользователем (чтение/запись из консоли, из файла, из параметров командной строки), форматы файлов и др.
Используем файловый ввод-вывод. Из файла input.txt считываем исходную матрицу, при этом в первую строку файла поместим числа m и n - число строк и число столбцов исходной матрицы соответственно. Ответ задачи выводим в файл output.txt. Функция void \verb+ change_matrix()+ будет считывать матрицу, выделять память, вычислять ответ и писать новую матрицу в нужный файл. \\
После выделения памяти "побежим" по исходному двумерному массиву. Для вычисления каждого элемента B$_{i j}$ будем хранить ans и C (см. "Теоретические сведения$")$. Переменная \verb+pre_ans+ содержит ответ для предыдущего элемента B$_{i j-1}$. Чтобы найти C введем вспомогательную функцию \verb+int calc_column(int line, int col, int **arr)+. Функция получает три параметра: строку и столбец текущего элемента, а также указатель на двумерный массив. Результатом ее работы является число C. После вычисления элемента B$_{i j}$ напишем его в файл output.txt, затем обновим \verb+pre_ans+ (оно становится равно B$_{i j}$) и перейдем к следующему элементу. \\
После вычисления всех элементов не забудем закрыть файлы input.txt и output.txt и освободить память функцией free() из библиотеки stdlib.h. \\
Результат работы программы - двумерный массив, записанный в файл output.txt. 
\subsection{Описание тестового стенда и методики тестирования}
Среда разработки: Qt Creator 3.5.0 (opensource)\\
Компилятор: gcc (Debian 4.9.2-10) 4.9.2 \\
Операционная система: Debian GNU/Linux 8.1 \\
При решении задачи использовалось ручное тестирование. 
\subsection{Тестовый план и результаты тестирования}
\begin{enumerate}
\item Файл input.txt имеет следующий вид: \\
5 5 \\
1 2 3 4 5 \\
1 3 7 6 3 \\
2 8 1 2 4 \\
6 1 1 3 4 \\
5 8 6 1 2 \\
Результат работы программы в файле output.txt:\\
1 3 6 10 15 \\
2 7 17 27 35 \\
4 17 28 40 52 \\
10 24 36 51 67 \\
15 37 55 71 89 \\
Рассмотрим элемент A$_{2 3}$. В новой матрице он должен быть равен: 1 + 2 + 3 + 1 + 3 + 7 = 17, что мы и видим в результате работы программы. Вычислим новое значение элемента A$_{3 4}$: 1 + 2 + 3 + 4 + 1 + 3 + 7 + 6 + 2 + 8 + 1 + 2 = 40. В получившейся матрице элемент [3, 4] равен 40. 
\item Пусть теперь в файле input.txt записано следующее: \\
4 3 \\
1 1 1 \\
1 1 1 \\
1 1 1 \\
1 1 1 \\
После работы программы файл output.txt выглядит следующим образом: \\
1 2 3 \\
2 4 6 \\
3 6 9 \\
4 8 12 \\
Вычислим новое значение элемента A$_{4 3}$: 12 * 1 = 12, что и находится на месте [4, 3] в получившейся матрице. 
\end{enumerate} 
Утилита cppcheck нашла следующие ошибки: \\
\begin{enumerate}
\item (portability) scanf without field width limits can crash with huge input data on some versions of libc. \\
Эту ошибку несложно исправить указанием границы вводимой переменной.
\item (style) The scope of the variable 'pre\_ans' can be reduced.\\
Ошибка значит, что для переменной pre\_ans можно использовать short int вместо int. 
\end{enumerate}

\subsection{Выводы}
При решении задачи автор научился использовать файловый ввод-вывод на языке С, выделять динамически память для двумерного массива и работать с ним. Как показало тестирование, написанная программа верно находит ответ задачи. \\
\newpage

\chapter{Строки}
\section{Задание 1}
\subsection{Задание}
В текстовом файле представлены в виде таблтцы результаты соревнований по прыжкам в длину. В каждой строке файла записаны фамилия с инициалами спортсмена и через пробелы - его результаты в трех попытках. Найти трех призеров соревнования. \\
Иванов И.И. 720 732 735 \\
Петров П.П. 722 727 730 \\
Сидоров С.С. 721 733 738 \\
\subsection{Теоретические сведения}
%Конструкции языка, библиотечные функции, инструменты использованные при разработке приложения.
%Сведения о предметной области, которые позволили реализовать алгоритм решения задачи.
Результатом спортсмена является максимум из трех попыток. Для решения задачи необходимо определить результат каждого участника и выбрать трех человек с наилучшим. \\
Для чтения даных из файла подключим библиотеку stdlib.h. Для использования строковой функции strcpy(char$[]$, char$[]$) используем заголовочный файл string.h. 
\subsection{Проектирование}
%Какие функции было решено выделить, какие у этих функций контракты, как организовано взаимодействие с пользователем (чтение/запись из консоли, из файла, из параметров командной строки), форматы файлов и др.
Организуем структуру Competitors. В ней будет два поля: имя участника (фамилия и инициалы) - name и его лучший результат из трех попыток - res. Создадим переменные first, second, third и participant этого типа. Присвоим полю res первых трех переменных -1. Получать данные будем из файла "competitions.txt". Сведения о каждом участнике - это строка в файле. \\

Функция void \verb+ results_of_competitions()+- основная функция. В ней будут объявляться переменные и структура, а также считываться данные и выводиться ответ. Пока не достигнут конец файла, будем получать имя участника и три его результата. Делать это будем с помощью функций \verb+int find_name(char [40], struct Competitors*)+ и void \verb+ find_results(int, char [40], int [3])+.\\
Функция \verb+int find_name(char [40], struct Competitors*)+ ищет в строке файла имя и инициалы участника и записывает их в . Имя спортсмена находится в строке до второго пробела. Учитывая этот факт, функция посимвольно записывает имя и инициалы участника в строку participant.name. Как только достигается второй пробел, функция возвращает номер символа, который используется в дальнейшем в функции void \verb+ find_results(int, char [40], int [3])+.\\
Функция void \verb+ find_results(int, char [40], int [3])+ получает номер символа, который вернула предыдущая функция. Именно с этого символа функция начинает свою работу. Она считывает символы до пробела и записывает их в строку res. Затем, с помощью функции atoi(res), строка res преобразуется в число и записывается в массив результатов данного спортсмена. Функция обрабатывает три числа, разделенных пробелами, т.е. пока не достигнут символ перевода строки. \\
После разбора полученной из файла строки находим максимум в получившемся массиве результатов спортсмена и запишем его в participant.res. Таким образом в переменной participant записаны все сведения об участнике. \\
Теперь будем поочередно сравнивать получившуюся переменную participant с переменными first, second и third. Реализовывать это будет функция \verb+int compare_structs(struct Competitors*, struct Competitors*)+ Если participant.res больше first.res, то с помощью функции void \verb+ assigment_of_structs(struct Competitors *, struct Competitors *)+ заменим поля переменной first на поля переменной participant. Затем, той же функцией сдвинем тройку лучших: первый станет вторым, второй - третьим). \\
После сравнения структур перейдем к следующей итерации цикла. \\
Когда будет достигнут конец файла, цикл завершит свою работу. Закроем файл с исходными данными и перейдем к выводу ответа на экран. Выводить будем переменные first, second и third в том случае, если в поле res переменной не записано -1. 
\subsection{Описание тестового стенда и методики тестирования}
Среда разработки: Qt Creator 3.5.0 (opensource)\\
Компилятор: gcc (Debian 4.9.2-10) 4.9.2 \\
Операционная система: Debian GNU/Linux 8.1 \\
При решении задачи использовалось ручное тестирование. 
\subsection{Тестовый план и результаты тестирования}
При решении задачи было проведено ручное тестирование.
\begin{enumerate}
\item
Содержание исходного файла:
Ivanov I.I. 312 312 321 \\
Petrov V.B. 444 380 239 \\
Kozlov K.N. 323 990 234 \\
Sidorovich A.H. 700 902 492 \\
Kuznetsov D.L. 865 323 401 \\
Putin V.V. 3004 4242 4245 \\
Bereznin A.A. 594 442 689 \\
Pahomov S.I. 2999 0 0 \\
Grigorivich G.P. 544 9 234 \\
Mechenkov K.S. 333 3 3 \\
Naumenkov I.F. 90 880 353 \\
Saharov K.I. 390 399 3950 \\
Lopuhov T.M. 595 445 399 \\ \\
Результат работы программы: \\
I место: Putin V.V., результат: 4245 \\
II место: Saharov K.I., результат: 3950 \\
III место: Pahomov S.I., результат: 2999
\item 
Содержание исходного файла: \\
Ivanov I.I. 312 312 321 \\
Petrov V.B. 444 380 239 \\ \\
Результат работы программы: \\
I место: Petrov V.B., результат: 444 \\
II место: Ivanov I.I., результат: 321 \\
\end{enumerate}
Таким образом, программа прошла все представленные тесты. \\
Утилита cppcheck сообщила о стилевой ошибке, аналогичной в предыдущей задаче: \\
(style) The scope of the variable 'i' can be reduced.
\subsection{Выводы}
При решении задачи автор научился пользоваться некоторыми строковыми функциями в языке C. Получившаяся программа верно выводит ответ в каждом тесте. \\ \\
\newpage

\chapter{Инкапсуляция}
\section{Задание1}
\subsection{Задание}
Реализовать класс МАТРИЦА. Требуемые методы: конструктор, деструктор, копирование, сложение, вычитание, умножение матриц, умножение на число. 

\subsection{Теоретические сведения}
%Конструкции языка, библиотечные функции, инструменты использованные при разработке приложения.
%Сведения о предметной области, которые позволили реализовать алгоритм решения задачи.
Для выполнения этого задания, используем объектно-ориентированное программирование. Создадим класс Matrix, в котором и будут реализованы требуемые методы. Для того, чтобы сложить две матрицы, необходимо к каждому элементу первой матрицы прибывать соответствующий элемент второй матрицы. Аналогично вычитание матриц. Чтобы умножить матрицу на число, нужно каждый ее элемент умножить на это число. Операция умножения двух матриц выполнима только в том случае, если число столбцов в первом сомножителе равно числу строк во втором. \\
Для копирования, сложения, вычитания, умножения и умножения на число перегрузим операторы. Если размеры матриц неравны при сложении, копировании и вычитании, введем исключение. Если матрицы при умножении не соответствуют условию, будем "бросать" другое исключение. 
\subsection{Проектирование}
%Какие функции было решено выделить, какие у этих функций контракты, как организовано взаимодействие с пользователем (чтение/запись из консоли, из файла, из параметров командной строки), форматы файлов и др.
В классе Matrix имеются public-методы и private-переменные. Размеры матрицы и ее содержимое будет private. Публичными будут следующие методы: конструктор, конструктор копирования, деструктор, все перегруженные операторы, функции, возвращающие количество столбцов и строк матрицы, а так же функции, устанавливающие и получающие значение элемента матрицы. \\
В конструкторе сначала инициализируем размеры матрицы числами, с которыми он вызовется. Стандартные размеры будут $5\times5$, n - количество строк матриц, а m - количество столбцов. Затем, с помощью функции new, выделим память для матрицы: сначала для массива (длинной n) указателей на массивы, потом для самих n массивов, длинны m. После выделения памяти инициализируем матрицу нулями. \\
Конструктор копирования вызывается для матрицы, которая передается как параметр функции. В нем выделим память под копию матрицы и инициализируем ее. \\
В деструкторе будем освобождать память в обратном порядке ее выделения. Т.е. сначала очистим память для n массивов, а затем удалим массив указателей. \\
Перегрузка оператора присваивания. Обозначим матрицу, которой присваивают, - Matrix1; матрица, которую присваивают - Matrix2. Во-первых, учтем тот факт, что мы не можем присваивать друг другу матрицы разных размеров. Поэтому перед реализацией проверим, являются ли размеры матриц равными. Если размеры матриц неравны, возбудим исключение UnequalMatrix. После проверки размеров матриц, освободим память матрицы Matrix1, затем выделим новую память для этой же матрицы и скопируем в нее элементы Matrix2 с помощью метода set(int, int, int).\\
Метод void set(int i, int j, int value) устанавливает в элемент с индексом [i, j] значение value. \\
Метод int get(int i, int j) возвращает значение элемента с индексом [i, j]. \\
Перегрузка оператора сложения. Перед суммированием матриц проверим, являются ли их размеры равными. Если нет, "бросим" исключение UnequalMatrix, как в операторе присваивания. После проверки создадим матрицу result с размерами, аналогичными размерам суммируемых матриц. Каждому элементу матрицы result присвоим сумму соответствующих элементов складываемых матриц. Возвращать будем матрицу result. \\
Аналогично перегрузим оператор вычитания. \\
Для реализации умножения на число number перегрузим оператор умножения. Здесь нам не важен размер матрицы. Создадим матрицу result таких же размеров, как исходная. Затем каждый элемент исходной матрицы умножим на number и присвоим результат в соответствующий элемент матрицы result. Вернем матрицу result. \\
Перегрузка оператора умножения матрицы на матрицу. Перед началом умножения проверим условие, которое позволяет умножить матрицу Matrix1 на матрицу Matrix2. Если количество столбцов матрицы Matrix1 равно количеству строк Matrix2, то можно выполнять умножение матрицы Matrix1 на Matrix2. В противном случае возбудим исключение Impossible- Multiplication. После проверки условия введем матрицу result. Количество ее строк будет равно количеству строк матрицы Matrix1, а число столбцов - числу столбцов матрицы Matrix2. По правилу умножения матриц будем находить каждый элемент матрицы result. После выполнения всех действий, вернем result. \\
Методы int getNumOfCols() и int getNumOfRows() возвращают количество столбцов и строк матрицы соответственно. 
\subsection{Описание тестового стенда и методики тестирования}
Среда разработки: Qt Creator 3.5.0 (opensource)\\
Компилятор: gcc (Debian 4.9.2-10) 4.9.2 \\
Операционная система: Debian GNU/Linux 8.1 \\
При решении задачи использовалось автоматическое тестирование. 
\subsection{Тестовый план и результаты тестирования}
\begin{enumerate}
\item
Тестирование суммы, разности матриц, а так же методов getNumOfRows и getNumOfCols. \\
Введем матрицы matrix1(2, 3), matrix2(2, 3), matrix3(2, 3). Последняя матрица будет содержать результаты действий с первыми двумя. \\
$matrix1 = \begin{pmatrix} 2 & 1 & 4 \\ 3 & 2 & 5 \end{pmatrix}$; 	$matrix2 = \begin{pmatrix} 3 & 4 & 3 \\ 2 & 7 & 1 \end{pmatrix}$.\\
Метод getNumOfRows(matrix1) вернул 2, метод getNumOfCols(matrix2) вернул 3, что соответствует действительности. 
Сложим их и проверим некоторые элементы матрицы matrix3. matrix3.get(0, 0) = 5; matrix3.get(1, 1) = 9; matrix3.get(1, 2) = 6. При "ручном" сложении матриц можно убедиться, что данные элементы имеют именно такие значения. \\
Вычтем матрицу matrix2 из matrix1. Так же проверим некоторые элементы. matrix3.get(0, 1) = -3; matrix3.get(1, 0) = 1; matrix3.get(1, 1) = -5. Это не противоречит ожидаемому результату. \\
\item 
Тестирование умножения на число. Возьмем матрицу matrix3 из предыдущего пункта. Умножим ее на 4 и проверим некоторые ее элементы. matrix3.get(0, 1) = -12; matrix3.get(1, 1) = -20. Сравним эти элементы с элементами из предыдущего пункта. Очевидно, что матрица умножилась верно. 
\item 
Тестирование умножения матрицы на матрицу. Для этого создадим матрицы matrix4(3, 3) и matrix5(2, 3). Будем умножать matrix1 из первого пункта на matrix4. Результатом умножения является матрица matrix5. \\
$matrix1 = \begin{pmatrix} 2 & 1 & 4 \\ 3 & 2 & 5 \end{pmatrix}$; $matrix5 = \begin{pmatrix}
0 & -2 & 3 \\ 1 & 3 & 4 \\ 6 & 2 & -1 \end{pmatrix} $ \\
После умножения должна получиться матрица: $matrix4 = \begin{pmatrix} 25 & 7 & 6 \\ 32 & 10 & 12 \end{pmatrix}$ \\
После проверки каждого элемента полученной матрицы, оказалось, что результат умножения оправдал наши ожидания.
\end{enumerate}
Так же в тестировании использовались методы set и get, а так же оператор присваивания. Они работают верно.\\
Cppcheck не нашел ошибок в этом задании. 
\subsection{Выводы}
При решении задачи, автор впервые столкнулся с объектно-ориентированным программированием; узнал, что такое класс, методы класса, какими бывают методы; научился перегружать операторы, возбуждать исключения, а так же пользоваться утилитой для статического анализа кода Cppcheck. Получившийся класс МАТРИЦА содержит все требуемые в условии методы. Результаты их работы соответствуют ожидаемым. Можно сделать вывод, что задание выполнено верно. \\ 

\subsection*{Листинги}
\subsubsection{Функция main}
\lstinputlisting[]
{../sources/Subdirproject/app/main.c}
\newpage

\subsubsection{Задача 1. Длина отрезка}
\lstinputlisting[]
{../sources/Subdirproject/app/1_length_of_segment_ui.c}

\lstinputlisting[]
{../sources/Subdirproject/lib/1_length_of_segment.c}
\newpage

\subsubsection{Задача 2. Биквадратное уравнение}
\lstinputlisting[]
{../sources/Subdirproject/app/2_equation_ui.c}

\lstinputlisting[]
{../sources/Subdirproject/lib/2_equation.c}
\newpage

\subsection{Тесты к задаче 1 и задаче 2}
\lstinputlisting[]
{../sources/Subdirproject/test/tst_testtest.cpp}
\newpage

\subsubsection{Задача 3. Циклы}
\lstinputlisting[]
{../sources/Subdirproject/app/3_km_to_miles_ui.c}

\lstinputlisting[]
{../sources/Subdirproject/lib/3_km_to_miles.c}
\newpage

\subsubsection{Задача 4. Матрицы}
\lstinputlisting[]
{../sources/Subdirproject/app/4_matrix.c}
\newpage

\subsubsection{Задача 5. Строки}
\lstinputlisting[]
{../sources/Subdirproject/app/5_strings.c}

\lstinputlisting[]
{../sources/Subdirproject/lib/5_strings.c}
\newpage

\subsubsection{Задача 6. Инкапсуляция. МАТРИЦА}
\lstinputlisting[]
{../sources/Subdirproject/cpplib/matrix.h}

\lstinputlisting[]
{../sources/Subdirproject/cpplib/matrix.cpp}
\newpage

\subsubsection{Тесты для МАТРИЦЫ}
\lstinputlisting[]
{../sources/Subdirproject/CppTests/tst_cppteststest.cpp}

\end{document}
